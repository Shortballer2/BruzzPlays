<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Basketball Sim v15.0 (Spacing Engine)</title>
    <style>
        :root { --blue: #2563eb; --red: #dc2626; --dark: #0f172a; --text: #f8fafc; }
        body { margin: 0; background: #050505; color: var(--text); font-family: 'Segoe UI', monospace; overflow: hidden; user-select: none; }
        
        /* UI LAYOUT */
        .screen { position: absolute; inset: 0; display: none; }
        .screen.active { display: block; }

        /* HUD */
        .tv-hud {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; align-items: flex-end; font-weight: 900; 
            filter: drop-shadow(0 10px 20px rgba(0,0,0,0.8));
        }
        .hud-bar { display: flex; background: #111; border: 2px solid #333; border-radius: 8px; overflow: hidden; }
        .hud-team { width: 90px; padding: 15px; text-align: center; font-size: 20px; color: white; display: flex; align-items: center; justify-content: center; }
        .hud-score { width: 70px; background: #fff; color: #000; font-size: 36px; display: flex; align-items: center; justify-content: center; font-family: monospace; }
        .hud-clock { background: #222; color: #f00; width: 110px; font-size: 28px; display: flex; align-items: center; justify-content: center; font-family: monospace; border-left: 1px solid #444; }

        /* MENUS */
        #menu { background: #080808; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .title { font-size: 80px; font-weight: 900; line-height: 0.9; text-align: center; margin-bottom: 40px; text-transform: uppercase; letter-spacing: -2px; }
        .btn { 
            background: transparent; border: 1px solid #444; color: white; padding: 20px 60px; 
            font-size: 16px; font-weight: 900; margin: 10px; cursor: pointer; width: 350px; 
            text-transform: uppercase; letter-spacing: 2px; transition: 0.2s;
        }
        .btn:hover { background: #fff; color: #000; transform: scale(1.05); }
        .btn.primary { border-color: var(--blue); color: var(--blue); }
        .btn.primary:hover { background: var(--blue); color: white; }

        /* PAUSE MENU */
        .pause-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.9); z-index: 100; display: none; flex-direction: column; align-items: center; justify-content: center; }
        .pause-overlay.active { display: flex; }
        
        /* NOTIFICATIONS */
        .notify { position: absolute; top: 150px; left: 50%; transform: translateX(-50%); font-size: 60px; font-weight: 900; color: #fbbf24; text-shadow: 0 5px 20px black; pointer-events: none; opacity: 0; transition: opacity 0.2s; text-align: center; width: 100%; }
        
        .debug-overlay { position: absolute; top: 10px; right: 10px; font-size: 10px; color: #444; font-family: monospace; pointer-events: none; text-align: right; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.150.1/three.min.js"></script>
</head>
<body>

    <div id="menu" class="screen active">
        <div class="title">Pro<br><span style="color:var(--blue)">Spacing</span> Engine</div>
        <div style="color:#666; margin-bottom:40px; letter-spacing: 3px;">V15.0 AI OVERHAUL</div>
        <button class="btn primary" onclick="initGame()">Start Match</button>
        <button class="btn" onclick="alert('Roster Editor in DLC')">Rosters</button>
    </div>

    <div id="game" class="screen">
        <div class="tv-hud">
            <div class="hud-bar">
                <div class="hud-team" style="background:var(--blue)">HOME</div>
                <div class="hud-score" id="sc-h">0</div>
                <div class="hud-score" id="sc-a">0</div>
                <div class="hud-team" style="background:var(--red)">AWAY</div>
                <div class="hud-clock" id="clock">12:00</div>
            </div>
        </div>
        <div class="notify" id="notify">SWISH!</div>
        <div class="debug-overlay">AI SPACING: 5-OUT<br>DEFENSE: MAN-TO-MAN</div>
        
        <div id="pause" class="pause-overlay">
            <h1 style="font-size:60px; margin-bottom:40px;">PAUSED</h1>
            <div style="display:flex; gap:40px; margin-bottom:40px;">
                <div id="box-h" style="text-align:right"></div>
                <div id="box-a" style="text-align:left"></div>
            </div>
            <button class="btn" onclick="togglePause()">RESUME</button>
            <button class="btn" onclick="location.reload()">QUIT</button>
        </div>
    </div>

    <script>
        // --- 1. SPACING ENGINE (The Fix for Clumping) ---
        // Coordinates for the 5-Out Offense slots relative to the hoop
        const SLOTS = [
            { id: 0, name: 'TOP', x: 0, z: 30 },
            { id: 1, name: 'WING_L', x: -22, z: 22 },
            { id: 2, name: 'WING_R', x: 22, z: 22 },
            { id: 3, name: 'CORNER_L', x: -24, z: 2 },
            { id: 4, name: 'CORNER_R', x: 24, z: 2 }
        ];

        // --- 2. GAME STATE ---
        const Game = {
            active: false, paused: false, clock: 720,
            possession: 'home', // 'home' or 'away'
            state: 'play', // 'play', 'shot', 'reset'
            scores: { home: 0, away: 0 },
            teams: {
                home: { id: 'home', color: 0x2563eb, roster: [] },
                away: { id: 'away', color: 0xdc2626, roster: [] }
            }
        };

        // --- 3. 3D SETUP ---
        let scene, camera, renderer;
        let actors = [], ball;
        const keys = {};

        function initGame() {
            document.getElementById('menu').classList.remove('active');
            document.getElementById('game').classList.add('active');
            
            // Scene
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.Fog(0x050505, 40, 150);
            
            camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, 85); camera.lookAt(0,0,0);
            
            renderer = new THREE.WebGLRenderer({antialias:true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game').appendChild(renderer.domElement);

            // Lights
            const amb = new THREE.AmbientLight(0xffffff, 0.5); scene.add(amb);
            const sun = new THREE.DirectionalLight(0xffffff, 1.2); 
            sun.position.set(20, 80, 30); sun.castShadow = true;
            sun.shadow.mapSize.set(2048,2048); scene.add(sun);

            // Court
            const cvs = document.createElement('canvas'); cvs.width=1024; cvs.height=2048; const ctx=cvs.getContext('2d');
            ctx.fillStyle='#e0b080'; ctx.fillRect(0,0,1024,2048); // Wood
            ctx.fillStyle='#1e3a8a'; ctx.fillRect(362,0,300,380); ctx.fillRect(362,1668,300,380); // Paint
            ctx.strokeStyle='white'; ctx.lineWidth=15; ctx.strokeRect(50,50,924,1948); // Border
            ctx.beginPath(); ctx.moveTo(50,1024); ctx.lineTo(974,1024); ctx.stroke(); // Half
            ctx.beginPath(); ctx.arc(512,140,450,0,Math.PI); ctx.stroke(); // 3PT
            ctx.beginPath(); ctx.arc(512,1908,450,Math.PI,0); ctx.stroke();
            
            const tex = new THREE.CanvasTexture(cvs); tex.anisotropy=16;
            const court = new THREE.Mesh(new THREE.PlaneGeometry(50,94), new THREE.MeshStandardMaterial({map:tex, roughness:0.4}));
            court.rotation.x = -Math.PI/2; court.receiveShadow=true; scene.add(court);

            // Hoops
            const makeHoop = (z) => {
                const g = new THREE.Group();
                const p = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,14), new THREE.MeshStandardMaterial({color:0x222})); p.position.y=7; g.add(p);
                const b = new THREE.Mesh(new THREE.BoxGeometry(6,4,0.1), new THREE.MeshStandardMaterial({color:0xffffff})); b.position.set(0,13,1); g.add(b);
                const r = new THREE.Mesh(new THREE.TorusGeometry(1.5,0.1), new THREE.MeshStandardMaterial({color:'orange'})); r.position.set(0,11,3); r.rotation.x=Math.PI/2; g.add(r);
                g.position.z=z; if(z>0) g.rotation.y=Math.PI; scene.add(g);
            }
            makeHoop(-47); makeHoop(47);

            // Spawn Players
            actors = [];
            spawnTeam(Game.teams.home, 1);
            spawnTeam(Game.teams.away, -1);

            // Ball
            ball = { mesh: new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshStandardMaterial({color:'orange'})), pos: new THREE.Vector3(0,5,0), vel: new THREE.Vector3(), owner:null, state:'loose' };
            scene.add(ball.mesh);

            // Assign Matchups & Give Ball
            actors.forEach(a => {
                if(a.team === 'home') {
                    a.matchup = actors.find(b => b.team === 'away' && b.role === a.role);
                    a.matchup.matchup = a;
                }
            });
            ball.owner = actors[0]; ball.state='dribble';

            Game.active = true;
            animate();
        }

        // --- 4. PLAYER RIG GENERATOR (Humanoid) ---
        function spawnTeam(team, dir) {
            for(let i=0; i<5; i++) {
                const g = new THREE.Group();
                
                // Materials
                const matJer = new THREE.MeshStandardMaterial({color:team.color});
                const matSkin = new THREE.MeshStandardMaterial({color:0x8d5524});
                
                // --- Skeleton ---
                const hip = new THREE.Group(); hip.position.y = 3; g.add(hip);
                
                // Torso
                const torso = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.8, 0.6), matJer);
                torso.position.y = 1; hip.add(torso);
                
                // Head
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.8, 0.7), matSkin);
                head.position.y = 2.4; hip.add(head);

                // Arms
                const mkLimb = (x, col) => {
                    const l = new THREE.Group(); l.position.set(x, 1.8, 0);
                    const upper = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.2, 0.3), col); upper.position.y=-0.6;
                    l.add(upper); return l;
                }
                const armL = mkLimb(-0.8, matSkin); hip.add(armL);
                const armR = mkLimb(0.8, matSkin); hip.add(armR);

                // Legs
                const mkLeg = (x) => {
                    const l = new THREE.Group(); l.position.set(x, 0, 0);
                    const thigh = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.5, 0.4), matJer); thigh.position.y=-0.75;
                    const shin = new THREE.Mesh(new THREE.BoxGeometry(0.35, 1.5, 0.35), matSkin); shin.position.y=-2.25;
                    l.add(thigh, shin); return l;
                }
                const legL = mkLeg(-0.4); hip.add(legL);
                const legR = mkLeg(0.4); hip.add(legR);

                g.position.set(0, 0, dir*20); // Temp spawn
                scene.add(g);

                // Add to Logic list
                team.roster.push({
                    name: `Player ${i+1}`,
                    pts: 0, ast: 0
                });

                actors.push({
                    mesh: g, limbs: {hip, legL, legR, armL, armR},
                    team: team.id, role: i, // 0=PG, 1=SG...
                    matchup: null,
                    user: (team.id==='home' && i===0)
                });
            }
        }

        // --- 5. AI & PHYSICS LOOP ---
        function animate() {
            if(!Game.active) return;
            requestAnimationFrame(animate);
            if(Game.paused) return;

            // 1. UPDATE PLAYERS
            actors.forEach(a => {
                let move = new THREE.Vector3();
                const hoopZ = a.team==='home' ? -43 : 43; // Attacking Hoop
                const defZ = a.team==='home' ? 43 : -43;  // Defending Hoop

                // --- OFFENSE AI ---
                if(Game.possession === a.team) {
                    if(ball.owner === a) {
                        // BALL HANDLER
                        if(a.user) {
                            if(keys['ArrowUp']) move.z-=1; if(keys['ArrowDown']) move.z+=1;
                            if(keys['ArrowLeft']) move.x-=1; if(keys['ArrowRight']) move.x+=1;
                            if(move.lengthSq()>0) move.normalize().multiplyScalar(0.2);
                        } else {
                            // CPU Handler: Attack rim slowly
                            const dx = 0 - a.mesh.position.x;
                            const dz = hoopZ - a.mesh.position.z;
                            if(Math.abs(dz) > 5) move.set(dx,0,dz).normalize().multiplyScalar(0.15);
                        }
                    } else {
                        // OFF BALL (5-OUT SPACING)
                        // Map role to slot.
                        // Home attacks neg Z. Away attacks pos Z.
                        const slot = SLOTS[a.role]; 
                        const tz = a.team==='home' ? (hoopZ + slot.z) : (hoopZ - slot.z);
                        const tx = slot.x;
                        
                        // Move to slot
                        const dx = tx - a.mesh.position.x;
                        const dz = tz - a.mesh.position.z;
                        if(Math.sqrt(dx*dx+dz*dz) > 1.0) {
                            move.set(dx, 0, dz).normalize().multiplyScalar(0.18);
                        }
                    }
                } 
                // --- DEFENSE AI ---
                else {
                    if(a.matchup) {
                        // Stay between man and hoop (Sag logic)
                        const manPos = a.matchup.mesh.position;
                        const goalPos = new THREE.Vector3(0,0,defZ);
                        // Lerp 30% from Man to Hoop
                        const guardSpot = new THREE.Vector3().lerpVectors(manPos, goalPos, 0.3);
                        
                        const dx = guardSpot.x - a.mesh.position.x;
                        const dz = guardSpot.z - a.mesh.position.z;
                        if(Math.sqrt(dx*dx+dz*dz) > 0.5) {
                            move.set(dx,0,dz).normalize().multiplyScalar(0.17);
                        }
                    }
                }

                // COLLISION
                actors.forEach(b => {
                    if(a!==b && a.mesh.position.distanceTo(b.mesh.position) < 1.5) {
                        const push = a.mesh.position.clone().sub(b.mesh.position).normalize().multiplyScalar(0.05);
                        move.add(push);
                    }
                });

                // APPLY & ANIMATE
                a.mesh.position.add(move);
                if(move.lengthSq() > 0.001) {
                    a.mesh.lookAt(a.mesh.position.clone().add(move));
                    // Run Cycle
                    const t = Date.now()*0.015;
                    a.limbs.legL.rotation.x = Math.sin(t);
                    a.limbs.legR.rotation.x = -Math.sin(t);
                    a.limbs.armL.rotation.x = -Math.sin(t);
                    a.limbs.armR.rotation.x = Math.sin(t);
                } else {
                    // Idle
                    a.limbs.legL.rotation.x = 0; a.limbs.legR.rotation.x = 0;
                }
            });

            // 2. BALL PHYSICS
            if(ball.owner) {
                const p = ball.owner.mesh.position;
                ball.mesh.position.set(p.x + Math.sin(Date.now()*0.01)*1.5, 4 + Math.abs(Math.sin(Date.now()*0.015)*2), p.z + 1.5);
            } else {
                ball.mesh.position.add(ball.vel);
                ball.vel.y -= 0.02; // Grav
                
                // Floor
                if(ball.mesh.position.y < 0.6) {
                    ball.mesh.position.y = 0.6; ball.vel.y *= -0.6;
                }

                // Bounds
                if(Math.abs(ball.mesh.position.z) > 48 || Math.abs(ball.mesh.position.x) > 26) {
                    notify("OUT OF BOUNDS");
                    resetPlay(Game.possession==='home'?'away':'home');
                }

                // Scoring
                const hoopZ = Game.possession==='home' ? -41 : 41; // Target
                // Check dist to hoop center
                if(Math.abs(ball.mesh.position.z - hoopZ) < 2 && Math.abs(ball.mesh.position.x) < 2 && ball.mesh.position.y > 9 && ball.vel.y < 0) {
                    score(Game.possession);
                }
            }

            // Camera
            const focus = ball.owner ? ball.owner.mesh.position : ball.mesh.position;
            camera.position.x += (40 + focus.x*0.1 - camera.position.x)*0.05;
            camera.position.z += (focus.z*0.5 - camera.position.z)*0.05;
            camera.lookAt(focus.x, 0, focus.z);

            renderer.render(scene, camera);
        }

        // --- 6. LOGIC HELPERS ---
        function score(team) {
            Game.scores[team] += 2;
            document.getElementById('sc-h').innerText = Game.scores.home;
            document.getElementById('sc-a').innerText = Game.scores.away;
            notify("BUCKET!");
            resetPlay(team==='home'?'away':'home');
        }

        function resetPlay(nextPoss) {
            Game.possession = nextPoss;
            ball.owner = null; ball.vel.set(0,0,0);
            
            // Teleport ball to PG of next team
            const pg = actors.find(a => a.team === nextPoss && a.role === 0);
            ball.owner = pg;
            
            // Reset players to backcourt
            actors.forEach(a => {
                const zBase = a.team==='home' ? 20 : -20;
                a.mesh.position.set((a.role-2)*5, 0, zBase);
            });
        }

        function notify(msg) {
            const el = document.getElementById('notify');
            el.innerText = msg; el.style.opacity = 1;
            setTimeout(()=>el.style.opacity=0, 1500);
        }

        // Input
        window.onkeydown = e => { 
            if(e.key==='Escape') togglePause();
            if(e.key===' ') shoot();
            if(e.key.startsWith('Arrow')) keys[e.key]=true; 
        };
        window.onkeyup = e => { if(e.key.startsWith('Arrow')) keys[e.key]=false; };

        function shoot() {
            const u = actors.find(a=>a.user);
            if(ball.owner === u) {
                ball.owner = null;
                const hoopZ = u.team==='home' ? -43 : 43;
                const dx = 0 - u.mesh.position.x;
                const dz = hoopZ - u.mesh.position.z;
                ball.vel.set(dx*0.04, 0.9, dz*0.04);
            }
        }

        function togglePause() {
            Game.paused = !Game.paused;
            document.getElementById('pause').classList.toggle('active');
        }

    </script>
</body>
</html>
